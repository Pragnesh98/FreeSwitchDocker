#!KAMAILIO
##!define WITH_DEBUG
#!define WITH_POSTGRES
#!define WITH_AUTH
#!define WITH_USRLOCDB
#!define WITH_NAT
#!define WITH_ANTIFLOOD
#!define WITH_VOICEMAIL
#!define WITH_FREESWITCH
#!define WITH_PBX
#!define WITH_XHTTP
# #!define WITH_PRESENCE
#!define WITH_IPAUTH
#!define WITH_ALIASDB
#!define WITH_NATSIPPING
#!define WITH_MULTIDOMAIN
#!define WITH_TLS
#!define WITH_LOADBALANCE
#!define WITH_WEBSOCKETS
#!define WITH_PSTN
#!define WITH_XMLRPC
#!define WITH_REGISTRAR
#!define WITH_RLS
#!define WITH_UUID
# #!define WITH_ASYNC

##-------------------------------- Binding Kamailio Instance --------------------------------##

#!substdef "!MY_IP_ADDR!172.31.23.44!g"
#!substdef "!EXTERNAL_IP!13.36.87.234!g"
#!substdef "!MY_UDP_PORT!5060!g"
#!substdef "!MY_TCP_PORT!5060!g"
#!substdef "!MY_TLS_PORT!5061!g"
#!substdef "!MY_WS_PORT!5056!g"
#!substdef "!MY_WSS_PORT!7443!g"
#!substdef "!MY_UDP_ADDR!udp:MY_IP_ADDR:MY_UDP_PORT!g"
#!substdef "!MY_TCP_ADDR!tcp:MY_IP_ADDR:MY_TCP_PORT!g"
#!substdef "!MY_TLS_ADDR!tls:MY_IP_ADDR:MY_TLS_PORT!g"
#!substdef "!MY_WS_ADDR!tcp:MY_IP_ADDR:MY_WS_PORT!g"
#!substdef "!MY_WSS_ADDR!tls:MY_IP_ADDR:MY_WSS_PORT!g"

#!define DB_QUERY_TIMEOUT 5

##-------------------------------- Data Bases Settings --------------------------------##

#!define DBURL "postgres://postgres:BngrpF2vAqIdn4MbTVTUVUO9I@65.2.67.84:5432/kamailio"
#!define KAMDBH "ca=>postgres://postgres:BngrpF2vAqIdn4MbTVTUVUO9I@65.2.67.84:5432/kamailio"
#!define UCALLDBH "dbh=>postgres://postgres:BngrpF2vAqIdn4MbTVTUVUO9I@65.2.67.84:5432/ucall"

##-------------------------------- Global Parameters --------------------------------##

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' paramet	ers
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

# - flags
#   FLT_ - per transaction (message) flags
#	FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#!define FLT_DLG 9
#!define FLT_DLGINFO 10

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

#!define TRUSTED_ADR_GR_SBC    "2"
#!define TRUSTED_ADR_GR_FS     "1"

#!define FLAG_FROM_FS   11
#!define FLAG_FROM_SBC  12

#!define DEFAULT_DISPATCHER_GRP   "1"
#!define DEFAULT_DISPATCHER_ALGR  "4"

listen=MY_UDP_ADDR advertise EXTERNAL_IP:MY_UDP_PORT
listen=MY_TCP_ADDR advertise EXTERNAL_IP:MY_TCP_PORT
listen=MY_TLS_ADDR advertise EXTERNAL_IP:MY_TLS_PORT
#listen=MY_WS_ADDR advertise EXTERNAL_IP:MY_WS_PORT
listen=MY_WSS_ADDR advertise EXTERNAL_IP:MY_WSS_PORT


##-------------------------------- Global Parameters --------------------------------##
## [ LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR ]

#!ifdef WITH_DEBUG
debug = 3
log_stderror = no
#!else
debug = 2
log_stderror = no
#!endif
memdbg = 5
memlog = 5

log_facility = LOG_LOCAL0
check_via = no	# (cmd. line: -v)
dns = no          # (cmd. line: -r)
rev_dns = no      # (cmd. line: -R)

async_workers = 1
children = 4
disable_tcp = no
auto_aliases = no
http_reply_parse = yes
use_dns_cache = no
server_signature = no
server_header = "PBX-1.0.0"
user_agent_header = "User-Agent: PBX-10.0"
alias = "hepta-media.heptadial.com"
#!ifdef WITH_TLS
enable_tls = yes
#!endif

tcp_max_connections=8192
tls_max_connections=65536
tcp_connection_lifetime = 3605
tcp_accept_no_cl = yes
tcp_rd_buf_size = 16384
tcp_clone_rcvbuf = 1

mem_safety = 1
tcp_send_timeout = 120
tcp_no_connect = 0
mem_join = 1

log_name = "proxy"
log_prefix = "[$rm:$ci]"

#!define DS_PING_FROM    "sip:UCALL@ucall.com"

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

#!ifdef WITH_PSTN
/* PSTN GW Routing
 *
 * - pstn.gw_ip: valid IP or hostname as string value, example:
 * pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
 *
 * - by default is empty to avoid misrouting */
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
/* VoiceMail Routing on offline, busy or no answer
 *
 * - by default Voicemail server IP is empty to avoid misrouting */
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "5060" desc "VoiceMail Port"
#!endif

####### Modules Section ########

####### Modules Section ########

# /* set paths to location of modules */
# # mpath="/usr/local/lib64/kamailio/modules/"

loadmodule "db_postgres.so"
loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "dispatcher.so"

loadmodule "carrierroute.so"

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
loadmodule "presence_dialoginfo.so"
loadmodule "presence_mwi.so"
loadmodule "presence_afe.so"
loadmodule "pua.so"
loadmodule "pua_dialoginfo.so"
# loadmodule "pua_usrloc.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
# loadmodule "rtpproxy.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_WEBSOCKETS
loadmodule "xhttp.so"
loadmodule "websocket.so"
#!endif

loadmodule "sqlops.so"
loadmodule "dialog.so"
loadmodule "uac.so"

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

modparam("tm", "failure_reply_mode", 0)
modparam("tm", "remap_503_500", 0)
modparam("tm", "contacts_avp", "tm_contacts");
modparam("tm", "contact_flows_avp", "tm_contact_flows");
modparam("tm", "auto_inv_100", 1)
modparam("tm", "auto_inv_100_reason", "Trying")
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 1)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
# modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
# modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU */
modparam("registrar", "gruu_enabled", 0)

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif

modparam("carrierroute", "config_source", "db" )
modparam("carrierroute", "db_url", DBURL)
modparam("carrierroute", "carrierroute_table", "carrierroute")
modparam("carrierroute", "use_domain", 1)

#!ifdef WITH_AUTH
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "user_column", "username")
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "load_credentials", "")
modparam("auth_db", "use_domain", MULTIDOMAIN)
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif
#!endif

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
/* register callback to match myself condition with domains list */
# modparam("domain", "register_myself", 1)
#!endif


#!ifdef WITH_PRESENCE
modparam("presence", "db_url", DBURL)
modparam("presence", "fs_db_url", FUS_DBURL)
modparam("presence", "pbx_db_url", FUS_DBURL)
modparam("presence", "server_address", PRESENCE_ADDR)
modparam("presence", "send_fast_notify", 1)
modparam("presence", "db_update_period", 20)
modparam("presence", "clean_period", 10)
modparam("presence", "max_expires", 14430)
modparam("presence", "subs_db_mode", 0)
modparam("presence", "fetch_rows", 1000)
modparam("presence", "sip_uri_match", 1)
modparam("presence", "local_log_level", 4)
modparam("presence", "local_log_facility", "LOG_LOCAL3")
modparam("presence", "seconds_per_ring", SECONDS_PER_RING)
modparam("presence", "min_ring_count", MINIMUM_RING_COUNT)
modparam("presence", "ring_count_based_user_agents", RING_BASED_ON_COUNT_USER_AGENTS)
modparam("presence", "ring_seconds_based_user_agents", RING_BASED_ON_SECONDS_USER_AGENTS)

modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
modparam("presence_xml", "force_dummy_presence", 1)

modparam("presence_dialoginfo", "force_single_dialog", 0)
modparam("presence_dialoginfo", "force_dummy_dialog", 1)
modparam("presence_dialoginfo", "call_flow_feature_code_list", CALL_FLOW_FEATURE_CODE_LIST)
modparam("presence_dialoginfo", "call_park_feature_code_list", CALL_PARK_FEATURE_CODE_LIST)

modparam("pua", "db_url", DBURL)
modparam("pua", "db_mode", 0)
modparam("pua", "update_period", 20)
modparam("pua", "dlginfo_increase_version", 0)
modparam("pua", "reginfo_increase_version", 0)
modparam("pua", "check_remote_contact", 0)
modparam("pua", "fetch_rows", 1000)
modparam("pua", "outbound_proxy", OUTBOUND_PROXY)
modparam("pua", "db_url", DBURL)

modparam("pua_dialoginfo", "include_callid", 1)
modparam("pua_dialoginfo", "send_publish_flag", FLT_DLGINFO)
modparam("pua_dialoginfo", "caller_confirmed", 1)
modparam("pua_dialoginfo", "callee_trying", 1)
modparam("pua_dialoginfo", "include_tags", 1)
modparam("pua_dialoginfo", "override_lifetime", 10)
modparam("pua_dialoginfo", "pubruri_caller_dlg_var", "pubruri_caller")
modparam("pua_dialoginfo", "pubruri_callee_dlg_var", "pubruri_callee")
modparam("pua_dialoginfo", "call_park_feature_code_list", CALL_PARK_FEATURE_CODE_LIST)
modparam("pua_dialoginfo", "call_flow_feature_code_list", CALL_FLOW_FEATURE_CODE_LIST)
modparam("pua_dialoginfo", "internal_fs_port", LOCAL_ROUTING_FS_PORT)
modparam("pua_dialoginfo", "external_fs_port", PSTN_ROUTING_FS_PORT)
modparam("pua_dialoginfo", "sbc_ip_list", SBC_IP_LIST)
modparam("pua_dialoginfo", "db_url", DBURL)
modparam("pua_dialoginfo", "domain_list_hdr","Subscription-Domain-List")
modparam("pua_dialoginfo", "enable_special_call_handling",ENABLE_SPECIAL_CALL_HANDLING)
modparam("pua_dialoginfo", "call_pickup_feature_code_len",CALL_PICKUP_FEATURE_CODE_LEN)
modparam("pua_dialoginfo", "call_pickup_feature_codes",CALL_PICKUP_FEATURE_CODES)
modparam("pua_dialoginfo", "call_barge_feature_code_len",CALL_BARGE_FEATURE_CODE_LEN)
modparam("pua_dialoginfo", "call_barge_feature_codes",CALL_BARGE_FEATURE_CODES)
modparam("pua_dialoginfo", "call_park_no_refer_user_agents",CALL_PARK_NO_REFER_USER_AGENTS)
#modparam("pua_dialoginfo", "xcap_host",XCAP_HOST)
#modparam("pua_dialoginfo", "xcap_port",XCAP_PORT)
modparam("pua_dialoginfo", "supported_call_types",CALL_TYPES_FOR_MONITOR)

# modparam("pua_usrloc", "default_domain", DEFAULT_DOMAIN)
# modparam("pua_usrloc", "branch_flag", FLT_DLGINFO)
#!endif
/*
modparam("uac","auth_username_avp","$avp(auser)")
modparam("uac","auth_password_avp","$avp(apass)")
modparam("uac","auth_realm_avp","$avp(arealm)")
modparam("uac","reg_db_url",DBURL)
modparam("uac", "reg_contact_addr", "172.31.13.116:5060")
*/

modparam("uac","auth_username_avp","$avp(auser)")
modparam("uac","auth_password_avp","$avp(apass)")
modparam("uac","auth_realm_avp","$avp(arealm)")
modparam("uac","reg_db_url",DBURL)
modparam("uac", "reg_contact_addr", "13.36.87.234:5060")


modparam("dialog", "dlg_flag", FLT_DLG)
modparam("dialog", "dlg_match_mode", 1)
modparam("dialog", "detect_spirals", 1)
modparam("dialog", "db_url", DBURL)
modparam("dialog", "db_mode", 1)
modparam("dialog", "enable_stats", 1)
modparam("dialog", "track_cseq_updates", 1)

# # ----- dialog params -----
# modparam("dialog", "db_url", DBURL)
# modparam("dialog", "enable_stats", 1)
# modparam("dialog", "db_mode", 1)
# modparam("dialog", "dlg_flag", FLT_DLG)

#!ifdef WITH_NAT
# ----- rtpproxy params -----
# modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7722")

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_force_run", 11)
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 0)
modparam("debugger", "log_level_name", "exec")
#!endif


#!ifdef WITH_WEBSOCKETS
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 1)
modparam("websocket", "verbose_list", 1)
modparam("websocket", "cors_mode", 2)

#!endif

modparam("dispatcher","db_url", DBURL)
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "setid_col", "setid")
modparam("dispatcher", "destination_col", "destination")
modparam("dispatcher", "flags_col", "flags")
modparam("dispatcher", "priority_col", "priority")
modparam("dispatcher", "ds_ping_from", DS_PING_FROM)
modparam("dispatcher", "ds_ping_interval",60 )
modparam("dispatcher", "ds_probing_mode", 0)
modparam("dispatcher", "ds_ping_reply_codes", "class=4;code=503;code=408")
modparam("dispatcher", "force_dst", 1)
modparam("dispatcher", "ds_probing_threshold", 3)


modparam("sqlops", "sqlcon", KAMDBH)
modparam("sqlops", "sqlcon", UCALLDBH)

####### Routing Logic ########


/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {

# 		xlog("L_INFO","[ucall-cc] =>MESSAGE :: $mb [$ci]\n");
	# per request initial checks
	route(REQINIT);

	# NAT detection
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
 #		xlog("L_INFO","[ucall-cc] =>MESSAGE :: $mb [$ci]\n");
	#	remove_hf("To");
		if (t_check_trans()) {
			route(RELAY);
		}
		exit;
	}

	# handle retransmissions
	if (!is_method("ACK")) {
		if(t_precheck_trans()) {
			t_check_trans();
			exit;
		}
		t_check_trans();
	}

	# handle requests within SIP dialogs
	route(WITHINDLG);

	### only initial requests (no To tag)

	# authentication
	route(AUTH);

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
		record_route();
	}

	# 1- message from SBC Proxy - trusted!
	if (is_method("INVITE") && isflagset(FLAG_FROM_SBC) ) {
		xlog("L_INFO","[ucall-cc] =>Request received From Gateway [$si:$sp], [$rm $ru][$ci]\n");

		append_hf("X-direction: Inbound\r\n");
		append_hf("X-DID: $tU\r\n");
		xlog("L_INFO", "[ucall-cc] =>DID Number : $tU\n");

		xlog("L_INFO","[ucall-cc] =>DID [$tU] Lookup To Get Domain Name Destination\n");

		sql_xquery("dbh","select domain_uuid::text as d_uuid,destination_data, destination_app,destination_caller_id_name,destination_caller_id_number, destination_cid_name_prefix, regexp_matches('$tU',destination_number_regex)::text as match from  v_destinations WHERE destination_enabled='true'","ra");

		$var(domain_uuid) = $xavp(ra=>d_uuid);
		xlog("L_INFO", "[ $ci ] : Domain UUID : $var(domain_uuid)\n");

		if (($var(domain_uuid) == $null) || $var(domain_uuid) == 0 ) 
		{
			setflag(FLT_ACCMISSED);
			xlog("L_ERR","[ucall-cc] =>DID Lookup Failed, DID $tU is UNMAPPED.");
			send_reply("603","Declined");
			exit;
		} else {
			$var(new_dst) = $xavp(ra=>destination_data);
			$var(destination_app) = $xavp(ra=>destination_app);
			if ( ($xavp(ra=>destination_data) != $null) && ($xavp(ra=>destination_data) != 0) ) 
			{
				sql_xquery("dbh","select domain_name::text as d_name from v_domains WHERE domain_enabled='true' and domain_uuid='$var(domain_uuid)'","ra");
				$var(domain_name) = $xavp(ra=>d_name);
				xlog("L_INFO", "[ucall-cc] =>Domain Name : $var(domain_name)\n");
				
				append_hf("X-DESTAPP: $var(destination_app)\r\n");
				xlog("L_INFO", "[ucall-cc] =>New Destination Application : $var(destination_app)\n");
				xlog("L_INFO", "[ucall-cc] =>New Destination Number : $var(new_dst)\n");
				
				if ($var(destination_app) == "campaign" || $var(destination_app) == "CAMPAIGN") 
				{
					append_hf("X-CAMPAIGN: $var(new_dst)\r\n");
					append_hf("X-CAMP-UUID: $var(new_dst)\r\n");
					##CAMPAIGN DIAL CODE *701
					$ru = "sip:" + "*701@" + $var(domain_name);
				} else {
					$ru = "sip:" + $var(new_dst) +"@" + $var(domain_name);
				}
				xlog("L_INFO", "[ucall-cc] =>New RU : $ru\n");
				#remove_hf("To");
				#$var(modified_to_header)= "sip:" + $var(new_dst) + "@" + $var(domain_name);
				#insert_hf("To: $var(modified_to_header) \r\n");
				append_hf("X-context: $var(domain_name)\r\n");
			}
			sql_result_free("ra");

			xlog("L_INFO","[ucall-cc] =>After DID Lookup [ToNum:$tU][RU:$ru][DU:$du]\n");
			route(ROUTE_TO_FS);
			exit;
		}
	}
	
	# 1- message from Freeswitch B2BUA - trusted!
	if (is_method("INVITE") && isflagset(FLAG_FROM_FS) ) {
		xlog("L_INFO","[ucall-cc] =>Request received From FS - B2BUA [$si:$sp], [$rm $ru][$ci]\n");
		route(FROM_FS_ROUTE);
	} else {
        if (is_method("INVITE")) {
		        append_hf("X-context: $fd\r\n");
			xlog("L_INFO","[ucall-cc] =>Request received From SIP client [$si:$sp], [$rm $ru][$ci]\n");
			route(FROM_SIP_ENDPOINT);
		}
	}
	
	route(REGISTRAR);

	if ($rU==$null) {
		# request with no Username in RURI
		sl_send_reply("484","Address Incomplete");
		exit;
	}
}

# Wrapper for relaying requests
route[RELAY] {

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
		if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	
# 	if (is_method("INVITE")) {
# 		if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
# 	}

 		xlog("L_INFO","[ucall-cc] =>MESSAGE :: $mb [$ci]\n");
    if(is_method("INVITE|BYE|UPDATE|CANCEL|ACK")) {
            setflag(FLT_DLGINFO);
            dlg_manage();
		
    }
        
	if (!t_relay()) {
		sl_reply_error();
	}
	exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
		if($sht(ipban=>$si)!=$null) {
			# ip is already blocked
			xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
			exit;
		}
#		if (!pike_check_req()) {
#			xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
#			$sht(ipban=>$si) = 1;
#			exit;
#		}
	}
#!endif
	if($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
		# silent drop for scanners - uncomment next line if want to reply
		# sl_send_reply("200", "OK");
		exit;
	}

	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
		sl_send_reply("200","Keepalive");
		exit;
	}

# 	if(!sanity_check("17895", "7")) {
# 		xlog("Malformed SIP message from $si:$sp\n");
# 		exit;
# 	}
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
	if (!has_totag()) return;

	if (loose_route()) {
		route(DLGURI);
		if (is_method("BYE")) {
			setflag(FLT_ACC); # do accounting ...
			setflag(FLT_ACCFAILED); # ... even if the transaction fails
		} else if ( is_method("ACK") ) {
			# ACK is forwarded statelessly
			route(NATMANAGE);
		} else if ( is_method("NOTIFY") ) {
			# Add Record-Route for in-dialog NOTIFY as per RFC 6665.
			record_route();
		}
		route(RELAY);
		exit;
	}

	if (is_method("UPDATE") ) {
		route(RELAY);
		exit;
	}
	
	if (is_method("SUBSCRIBE") && uri == myself) {
		# in-dialog subscribe requests
		route(PRESENCE);
		exit;
	}
	if ( is_method("ACK") ) {
		if ( t_check_trans() ) {
			route(RELAY);
			exit;
		} else {
			exit;
		}
	}
	sl_send_reply("404","Not here");
	exit;
}
# Handle SIP registrations
route[REGISTRAR] {
	if (!is_method("REGISTER")) return;

	# 1- message from Freeswitch B2BUA - trusted!
	if((is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_FS)) {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From Freeswitch\n");
		sl_send_reply("200","OK");
# 		return;
# 		if (!save("location")) {
# 			sl_reply_error();
# 		}
		exit;
	
	}
	
	
	if(isflagset(FLT_NATS)) {
		setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
		# do SIP NAT pinging
		setbflag(FLB_NATSIPPING);
#!endif
	}
	if (!save("location")) {
		sl_reply_error();
	}
	exit;
}

# User location service
route[LOCATION] {

#!ifdef WITH_SPEEDDIAL
	# search for short dialing - 2-digit extension
	if($rU=~"^[0-9][0-9]$") {
		if(sd_lookup("speed_dial")) {
			route(SIPOUT);
		}
	}
#!endif

#!ifdef WITH_ALIASDB
	# search in DB-based aliases
	if(alias_db_lookup("dbaliases")) {
		route(SIPOUT);
	}
#!endif

	$avp(oexten) = $rU;
	if (!lookup("location")) {
		$var(rc) = $rc;
# 		route(TOVOICEMAIL);
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) {
		setflag(FLT_ACCMISSED);
	}

	route(RELAY);
	exit;
}

# Presence server processing
route[PRESENCE] {
	if(!is_method("PUBLISH|SUBSCRIBE")) return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
# 		route(TOVOICEMAIL);
		# returns here if no voicemail server is configured
		sl_send_reply("404", "No voicemail service");
		exit;
	}

#!ifdef WITH_PRESENCE
	if (!t_newtran()) {
		sl_reply_error();
		exit;
	}

	if(is_method("PUBLISH")) {
		handle_publish();
		t_release();
	} else if(is_method("SUBSCRIBE")) {
		handle_subscribe();
		t_release();
	}
	exit;
#!endif

	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU==$null) {
		sl_send_reply("404", "Not here");
		exit;
	}
	return;
}

# IP authorization and user authentication
route[AUTH] {
	xlog("L_INFO","[ucall-cc]==>Request received [$si:$sp][$Ri:$Rp]\n");
	
#!ifdef WITH_AUTH

#!ifdef WITH_IPAUTH

	# 1- message from Freeswitch B2BUA - trusted!
	if((is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_FS)) {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From Freeswitch\n");
		return;
	}
	
	# 1- message from Freeswitch B2BUA - trusted!
	if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_FS)) {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From Freeswitch\n");
		setflag(FLAG_FROM_FS);
		return;
	}

	if((!is_method("REGISTER")) && $si == '172.31.23.44') {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From Freeswitch\n");
		setflag(FLAG_FROM_FS);
		return;
	}

	# 2- message from SBC Proxy - trusted!
	if((!is_method("REGISTER")) && allow_source_address(TRUSTED_ADR_GR_SBC)) {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From SBC\n");
		setflag(FLAG_FROM_SBC);
		return;
	}
	
# 	# 2- message from SBC Proxy - trusted!
# 	if(!is_method("REGISTER")) {
# 		$avp(src_adr) = $si;
# 		$avp(src_port) = "0";
# 		if (allow_address(TRUSTED_ADR_GR_SBC, "$avp(src_adr)", "$avp(src_port)") ) 
# 		{
# 	# 	&& allow_source_address(TRUSTED_ADR_GR_SBC)) {
# 			xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From SBC.\n");
# 			setflag(FLAG_FROM_SBC);
# 			return;
# 		}
# 	}
	
	# 3- message from Freeswitch B2BUA - trusted!
	if ((is_method("INVITE")) &&  allow_source_address(TRUSTED_ADR_GR_FS)) {
		xlog("L_INFO","[ucall-cc]==>Request received [$rm $ru] From Freeswitch\n");
		setflag(FLAG_FROM_FS);
		return;
	}        

#!endif

	if (is_method("REGISTER|INVITE")) {
		# authenticate requests
		if (!auth_check("$fd", "subscriber", "1")) {
			auth_challenge("$fd", "0");
			exit;
		}
		
		# user authenticated - remove auth header
		if(!is_method("REGISTER|PUBLISH"))
			consume_credentials();
	}
	
# 	# if caller is not local subscriber, then check if it calls
# 	# a local destination, otherwise deny, not an open relay here
# 	if (from_uri!=myself && uri!=myself) {
# 		sl_send_reply("403","Not relaying");
# 		exit;
# 	}
	
# 	if (is_method("REGISTER|INVITE")) {
# 		xlog("L_INFO","[ucall-cc]==>Request [$rm] Auth Checking\n");
# 		if (!auth_check("$fd", "subscriber", "1")) {
# 			switch ($retcode) {
# 				case -1:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -1 generic error - src ip: $si\n");
# 				t_reply("403", "Forbidden");
# 				exit;
# 				case -2:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -2 invalid password - src ip: $si\n");
# 				t_reply("500", "Internal Server Error");
# 				exit;
# 				case -3:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -3 invalid user - src ip: $si\n");
# 				t_reply("400", "Bad Request");
# 				exit;
# 				case -4:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -4 nonce exprired - src ip: $si\n");
# 				break;
# 				case -5:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -5 no credentials - src ip: $si\n");
# 				break;
# 				case -6:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -6 nonce reused - src ip: $si\n");
# 				break;
# 				case -8:
# # 				xlog("L_WARN", "[AUTH][$ci]==>Auth failed - code -8 authuser mismatch - src ip: $si\n");
# 				break;
# 			}
# 			
# 			xlog("L_INFO","[ucall-cc]==>Request [$rm] Auth Challenge\n");
# 			auth_challenge("$fd", "0");
# 			exit;
# 		}
# 
# 		if(!is_method("REGISTER|PUBLISH")) {
# 			xlog("L_INFO","[ucall-cc]==>Request [$rm] Consume Credentials\n");
# 			consume_credentials();
# 		}
# 	}
	 
#!endif

	return;
}


# Caller NAT detection
route[NATDETECT] {
	#!ifdef WITH_NAT

	if ((($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT)
				&& !(proto == WS || proto == WSS))) {
		if (nat_uac_test(64)) {
			force_rport();
			if (is_method("REGISTER")) {
				fix_nated_register();
			} else {
				fix_nated_contact();
				if (!add_contact_alias()) {
					xlog("L_ERR", "Error aliasing contact <$ct>\n");
					sl_send_reply("400", "Bad Request");
					exit;
				}
			}
		}
	} else {
		force_rport();
		if (nat_uac_test("19")) {
			if (is_method("REGISTER")) {
				fix_nated_register();
			} else {
				if(is_first_hop()) {
					set_contact_alias();
				}
			}
			setflag(FLT_NATS);
		}
	}
	
	#!endif
	return;
}

route[NATMANAGE] {
#!ifdef WITH_NAT

	if (is_request()) {
		if(has_totag()) {
			if(check_route_param("nat=yes")) {
				setbflag(FLB_NATB);
			}
		}
	}

	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) return;

	if (is_request()) {
		if (!has_totag()) {
			if(t_is_branch_route()) {
				add_rr_param(";nat=yes");
			}
		}
	}
	if (is_reply()) {
		if(isbflagset(FLB_NATB)) {
			if(is_first_hop())
				set_contact_alias();
		}
	}
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
#!ifdef WITH_NAT
	if(!isdsturiset()) {
		handle_ruri_alias();
	}
#!endif
	return;
}


# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
	# allow XMLRPC from localhost
	if ((method=="POST" || method=="GET")
			&& (src_ip==127.0.0.1)) {
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}
	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
	xdbg("new branch [$T_branch_idx] to $ru\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
	xlog("L_INFO","[kamailio] =>SIP Reply [$rs]\n");

	if(status=~"[12][0-9][0-9]") {
		route(NATMANAGE);
	}

	if(t_check_status("403")) {
		xlog("L_INFO","[kamailio] =>Busy Here [$rs]\n");
		t_reply("403","Forbidden");
		exit;
	} else if(t_check_status("487")) {
		xlog("L_INFO","[kamailio] =>Request Terminated [$rs]\n");
		t_reply("487","Request Terminated");
		exit;
	} else if(t_check_status("480")) {
		xlog("L_INFO","[kamailio] =>Temporarily Unavailable [$rs]\n");
		t_reply("480","Temporarily Unavailable");
		exit;
			} else if(t_check_status("404")) {
					xlog("L_INFO","[kamailio] =>Not Found [404].\n");
					t_reply("404","Not Found");
					exit;
			} else if(t_check_status("603")) {
					xlog("L_INFO","[kamailio] =>Decline [603].\n");
					t_reply("404","Decline");
					exit;
			} else if(t_check_status("486")) {
					xlog("L_INFO","[kamailio] =>Busy Here [486].\n");
				t_reply("486","Busy Here");
					exit;
			}

			if(t_check_status("5[0-9][0-9]|6[0-9][0-9]")) {
					exit;
			}

			if (t_check_status("3[0-9][0-9]")) {
					t_reply("404","Not found");
					exit;
			}

		if( (is_method("NOTIFY")) && ($rs == 200) )
		{
			if(nat_uac_test(1))
			{
				fix_nated_contact();
				return;
			}
		}
}

failure_route[REMOTE_AUTH] {
	route(NATMANAGE);
	if (t_is_canceled()) exit;

	route(NATMANAGE);

	if (t_is_canceled()) exit;
	if(t_check_status("486")) {
		xlog("L_INFO","[kamailio] =>Busy Here [486].\n");
		t_reply("486","Busy Here");
		exit;
	} else if(t_check_status("487")) {
		xlog("L_INFO","[kamailio] =>Request Terminated [487].\n");
		t_reply("487","Request Terminated");
		exit;
	} else if(t_check_status("403")) {
		xlog("L_INFO","[kamailio] =>Forbidden [403].\n");
		t_reply("403","Forbidden");
		exit;
	} else if(t_check_status("480")) {
		xlog("L_INFO","[kamailio] =>Temporarily Unavailable [480].\n");
		t_reply("480","Temporarily Unavailable");
		exit;
	} else if(t_check_status("603")) {
		xlog("L_INFO","[kamailio] =>Decline [603].\n");
		t_reply("603","Decline");
		exit;
	}
	
 	if(t_check_status("407")) {
 	
		sql_xquery("dbh","select siptrunk_username,siptrunk_password from v_siptrunks where  siptrunk_uuid='$hdr(X-siptrunk_uuid)' AND domain_uuid=(select domain_uuid from v_domains where domain_name='$hdr(X-context)')","ra");

# 		sql_xquery("dbh","select siptrunk_username,siptrunk_password,regexp_matches('$tU',scan_prefix)::text as match from v_siptrunks where  domain_uuid=(select domain_uuid from v_domains where domain_name='$hdr(X-context)')","ra");
		
 		$avp(auser) = $xavp(ra=>siptrunk_username);
		$avp(apass) = $xavp(ra=>siptrunk_password);
		xlog("L_INFO","[kamailio] =>Remote asked for authentication");
		uac_auth();
		t_relay();
		exit;
 	}
	if(t_check_status("4[0-9][0-9]|5[0-9][0-9]|6[0-9][0-9]")) {
		exit;
	}
	
	exit;
}

failure_route[SIP_ENDPOINT_FAILED] {
	route(NATMANAGE);
	if (t_is_canceled()) exit;

	xlog("L_INFO","[kamailio] =>RESPONSE-----> [$rs].\n");
	if(t_check_status("486")) {
		xlog("L_INFO","[kamailio] =>Busy Here [$rs].\n");
		t_reply("486","Busy Here");
		exit;
	} else if(t_check_status("487")) {
		xlog("L_INFO","[kamailio] =>Request Terminated [$rs].\n");
		t_reply("487","Request Terminated");
		exit;
	} else if(t_check_status("403")) {
		xlog("L_INFO","[kamailio] =>Forbidden [$rs].\n");
		t_reply("403","Forbidden");
		exit;
	} else if(t_check_status("480")) {
		xlog("L_INFO","[kamailio] =>Temporarily Unavailable [$rs].\n");
		t_reply("480","Temporarily Unavailable");
		exit;
	} else if(t_check_status("603")) {
		xlog("L_INFO","[kamailio] =>Decline [$rs].\n");
		t_reply("603","Decline");
		exit;

	} else if(t_check_status("488")) {
		xlog("L_INFO","[kamailio] =>Request Terminated [$rs].\n");
		t_reply("487","Request Terminated");
		exit;
	}
	if(t_check_status("4[0-9][0-9]|5[0-9][0-9]|6[0-9][0-9]")) {
		exit;
	}
}

failure_route[MANAGE_SIPTRUNK_FAILURE] {
	revert_uri();
	xlog("L_INFO","[kamailio] =>Response From SBC Server [$rs].\n");
	
	if (t_check_status("408|5[0-9][0-9]")) {
		xlog("L_INFO","[kamailio] =>Try To Find Another SBC Server.\n");

		if(!cr_route("ucall", "fallback", "$rU", "$rU", "call_id")){
			xlog("L_ERR","[kamailio] =>No Active SBC Server Found\n");
			t_reply("403", "Not allowed");
		} else {
			t_on_failure("MANAGE_SIPTRUNK_FAILURE");
			xlog("L_INFO","[kamailio] =>Request Route on SBC [DURI = $du and RURI = $ru].\n");
			route(RELAY);
			exit;
		}
	}
}

route[OUTBOUND_ROUTE] {
	xlog("L_INFO","[kamailio] =>Lookup SIP Trunk Server.\n");

# 	sql_xquery("dbh","select siptrunk_host,siptrunk_prefix,siptrunk_suffix,siptrunk_strip, regexp_matches('$tU',scan_prefix)::text as match,siptrunk_name from v_siptrunks where domain_uuid=(select domain_uuid from v_domains where domain_name='$hdr(X-context)')","ra");
	sql_xquery("dbh","select siptrunk_host,siptrunk_prefix,siptrunk_suffix,siptrunk_strip,siptrunk_name from v_siptrunks where siptrunk_uuid='$hdr(X-siptrunk_uuid)' AND domain_uuid=(select domain_uuid from v_domains where domain_name='$hdr(X-context)')","ra");
	
	$var(siptrunk_host) = $xavp(ra=>siptrunk_host);
	$var(siptrunk_prefix) = $xavp(ra=>siptrunk_prefix);
	$var(siptrunk_suffix) = $xavp(ra=>siptrunk_suffix);
	$var(siptrunk_strip) = $xavp(ra=>siptrunk_strip);
	$var(siptrunk_name) = $xavp(ra=>siptrunk_name);
	
	if ( $var(siptrunk_host) != $null && $var(siptrunk_host) !=0 )  {
		xlog("L_INFO", "[kamailio] =>SIPTRUNK Host : $var(siptrunk_host)\n");
		xlog("L_INFO", "[kamailio] =>SIPTRUNK strip : $var(siptrunk_strip)\n");
		xlog("L_INFO", "[kamailio] =>siptrunk_prefix : $var(siptrunk_prefix)\n");
		xlog("L_INFO", "[kamailio] =>siptrunk_suffix : $var(siptrunk_suffix)\n");
		xlog("L_INFO", "[kamailio] =>siptrunk_name : $var(siptrunk_name)\n");
		
		$var(ToNumber) = $tU;
		$var(NewToNumber) = $(var(ToNumber){s.substr,$var(siptrunk_strip),0}); 

		xlog("L_INFO", "[kamailio] =>ToNumber : $var(ToNumber)\n");
		xlog("L_INFO", "[kamailio] =>After Strip NewToNumber : $var(NewToNumber)\n");
		
		#$var(NewToNumber) = $var(siptrunk_prefix) + $var(NewToNumber);
		xlog("L_INFO", "[kamailio] =>After prefix NewToNumber : $var(NewToNumber)\n");
		
 		$du = "sip:" + $var(NewToNumber) + "@" + $var(siptrunk_host);
 		$ru = "sip:" + $var(NewToNumber) + "@" + $var(siptrunk_host);
 		xlog("L_INFO","[kamailio] =>Found remote user [$rU] on [$rd] via [$du]");
 		xlog("L_INFO","[kamailio] =>DU ::  [$du]");
 		
		t_on_failure("REMOTE_AUTH");
		//uac_replace_to("sip:123@93.90.194.97");
	//	uac_replace_to("$du");
	//	uac_replace_from("sip:$fU@$var(siptrunk_host)");
		remove_hf_re("^X-");
		route(RELAY);
		exit;
	} 
	xlog("L_ERR", "[kamailio] =>SIPTRUNK NOT FOUND\n");
	send_reply("404", "SIP Trunk Not Found");
	exit;
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
	route(NATMANAGE);

	if (t_is_canceled()) exit;
	if(t_check_status("486")) {
		xlog("L_INFO","[kamailio] =>Busy Here [486].\n");
		t_reply("486","Busy Here");
		exit;
	} else if(t_check_status("487")) {
		xlog("L_INFO","[kamailio] =>Request Terminated [487].\n");
		t_reply("487","Request Terminated");
		exit;
	} else if(t_check_status("403")) {
		xlog("L_INFO","[kamailio] =>Forbidden [403].\n");
		t_reply("403","Forbidden");
		exit;
	} else if(t_check_status("480")) {
		xlog("L_INFO","[kamailio] =>Temporarily Unavailable [480].\n");
		t_reply("480","Temporarily Unavailable");
		exit;
	} else if(t_check_status("603")) {
		xlog("L_INFO","[kamailio] =>Decline [603].\n");
		t_reply("603","Decline");
		exit;
	}

	if(t_check_status("401")) {
		sql_xquery("ca","SELECT username,password FROM subscriber WHERE username='$fU' AND domain='$fd'","ra");
		if($xavp(ra=>username) ) {
			 xlog("L_INFO","[kamailio] =>AUTH_CHALLANGE [$xavp(ra=>username)]\n");
        		$avp(auser) = $xavp(ra=>username);
        		$avp(apass) = $xavp(ra=>password);
        		uac_auth();
        		t_relay();
        		exit;
		}
	}

	if(t_check_status("4[0-9][0-9]|5[0-9][0-9]|6[0-9][0-9]")) {
		exit;
	}

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

}

# Routing to foreign domains
route[SIPOUT] {
	if (uri==myself) return;

	append_hf("P-hint: outbound\r\n");
	route(RELAY);
	exit;
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) {
		xlog("SCRIPT: PSTN routing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$")) return;

	# only local users allowed to call
	if(from_uri!=myself) {
		sl_send_reply("403", "Not Allowed");
		exit;
	}

	if (strempty($sel(cfg_get.pstn.gw_port))) {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	} else {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}

route[FROM_SIP_ENDPOINT] {
# 	append_hf("X-context: $fd\r\n");
# 	append_hf("X-direction: Local\r\n");

	sql_xquery("ca","SELECT username FROM subscriber WHERE username='$tU' AND domain='$fd'","ra");
	if($xavp(ra=>username) == $null ) 
	{
		sql_xquery("dbh","select domain_uuid::text as d_uuid,destination_data, destination_app,destination_caller_id_name,destination_caller_id_number, destination_cid_name_prefix, regexp_matches('$tU',destination_number_regex)::text as match from  v_destinations WHERE destination_enabled='true'","ra");
		$var(domain_uuid) = $xavp(ra=>d_uuid);
		if ( ($xavp(ra=>destination_data) != $null) && ($xavp(ra=>destination_data) != 0) ) 
		{
			xlog("L_INFO", "[ $ci ] : Domain UUID : $var(domain_uuid)\n");
			append_hf("X-direction: Inbound\r\n");
			append_hf("X-DID: $tU\r\n");
			xlog("L_INFO", "[ucall-cc] =>DID Number : $tU\n");
			xlog("L_INFO","[ucall-cc] =>DID [$tU] Lookup To Get Domain Name Destination\n");
		
			$var(domain_name) = $fd;
			xlog("L_INFO", "[ucall-cc] =>Domain Name : $var(domain_name)\n");

			$var(new_dst) =$xavp(ra=>destination_data);
			$var(destination_app) =$xavp(ra=>destination_app);
			xlog("L_INFO", "[ucall-cc] =>New Destination Number : $var(new_dst)\n");

			append_hf("X-DESTAPP: $var(destination_app)\r\n");
			xlog("L_INFO", "[ucall-cc] =>New Destination Application : $var(destination_app)\n");

			if ($var(destination_app) == "campaign" || $var(destination_app) == "CAMPAIGN") 
			{
				append_hf("X-CAMPAIGN: $var(new_dst)\r\n");
				append_hf("X-CAMP-UUID: $var(new_dst)\r\n");
				##CAMPAIGN DIAL CODE *701
				$ru = "sip:" + "*701@" + $var(domain_name);
				
			} else {
				$ru = "sip:" + $var(new_dst) +"@" + $var(domain_name);
			}
			xlog("L_INFO", "[ucall-cc] =>New RU : $ru\n");
			
# 			$ru = "sip:" + $var(new_dst) +"@" + $var(domain_name);
# 			xlog("L_INFO", "[ucall-cc] =>New RU : $ru\n");
		#	remove_hf("To");
		#	$var(modified_to_header)= "sip:" + $var(new_dst) + "@" + $var(domain_name);
		#	insert_hf("To: $var(modified_to_header) \r\n");
		}
		sql_result_free("ra");
	}
	
	xlog("L_INFO","[ucall-cc] =>Lookup Dispatcher To Get Active Media Server.\n");
	route(ROUTE_TO_FS);
	exit;
}

route[PROCESS_OPTIONS] {
	sl_send_reply("200","OK");
	exit;
}


#!ifdef WITH_WEBSOCKETS
event_route[xhttp:request] {
	
	xlog("L_INFO","[ucall-cc] =>Event Route : [xhttp:request] Request [$rv] $rm => $hu\n");

	set_reply_close();
	set_reply_no_connect();

	if ($Rp != MY_WS_PORT && $Rp != MY_WSS_PORT) 
	{
		xlog("L_ERR","[ucall-cc] =>HTTP request Forbidden.\n");
		xhttp_reply("403", "Forbidden", "", "");
		exit;
	}
	
	xlog("L_INFO","[ucall-cc] =>HTTP request Received [RP:$Rp][HU:$hu]\n");

	if ($hdr(Upgrade) =~ "websocket" && $hdr(Connection) =~ "Upgrade" && $rm=~"GET") {
		if ($hdr(Host) == $null ) {
			xlog("L_ERR","[ucall-cc] =>Bad host $hdr(Host)\n");
			xhttp_reply("403", "Forbidden", "", "");
			exit;
		}

		if (ws_handle_handshake()) {
			xlog("L_INFO","[ucall-cc] =>WebSocket Connection Successful.\n");
			exit;
		}
    }
	xlog("L_ERR","[ucall-cc] =>Invalid url[$hu][$Rp][$rb]\n");
	xhttp_reply("404", "Not found", "", "");
}

event_route[usrloc:contact-expired] {
	xlog("L_INFO","[ucall-cc] =>Expired contact for $ulc(exp=>aor)\n");
}

event_route[websocket:closed] {
	xlog("L_NOTICE","[ucall-cc] =>WebSocket connection from $si:$sp has closed\n");
}
#!endif


route[ROUTE_TO_FS]
{
	xlog("L_INFO","[ucall-cc] =>Lookup dispatcher.\n");

	if(!ds_select_dst(DEFAULT_DISPATCHER_GRP, DEFAULT_DISPATCHER_ALGR)) {
		xlog("L_ERR","Dispatcher failed to get freeswitch server.\n");
        send_reply("404", "Not Here");
        exit;
	}

	xlog("L_INFO","[ucall-cc] =>Routing call on freeswitch [$du].\n");
	
	t_set_fr(0,3000);
	t_on_failure("MANAGE_FAILURE");
	route(RELAY);
	exit;
}

##-------------------------------- request from B2BUA --------------------------------##

route[FROM_FS_ROUTE] 
{
	xlog("L_INFO","[ucall-cc] =>Request from freeswitch server [$si:$sp]\n");
	
	if (is_present_hf("X-ucall") && $hdr(X-ucall) == "outbound") {
		xlog("L_INFO","[ucall-cc] =>Request from freeswitch server [$si:$sp] -PSTN call\n");
			route(OUTBOUND_ROUTE);
			exit;
	} else {
		xlog("L_INFO","[ucall-cc] =>Request from freeswitch server [$si:$sp] -PSTN Local\n");
		route(SEND_TO_SIP_ENDPOINT);
	}
}

##-------------------------------- SIP client --------------------------------##

route[SEND_TO_SIP_ENDPOINT]
{
	t_on_failure("SIP_ENDPOINT_FAILED");
	route(ROUTE_TO_ALL);
}

##-------------------------------- resume route --------------------------------##

route[ROUTE_TO_ALL] 
{
	if (!lookup("location")) {
		$var(rc) = $rc;
		t_newtran();
		switch ($var(rc)) {
			case -1:
			case -3:
				sl_send_reply("404", "Not Found");
				exit;
			case -2:
				send_reply("405", "Method Not Allowed");
				exit;
		}
	}

	if($du == $null) {
		xlog("L_ERR","[ucall-cc] =>No Registered [$ru]\n");
# 		send_reply("404", "Not Here");
		drop();
		exit;
	}
	
	route(RELAY);
	exit;
}

reply_route
{
	xlog("L_INFO","[kamailio] =>[$si:$sp] Reply  received Callid[$ci],method[$rm], status[$rs]\n");

	if( (is_method("INVITE")) && ($rs == 180 || $rs == 183|| $rs==200))
	{
		if(nat_uac_test(1))
		{
			fix_nated_contact();
			return;
		}
	}
	else if( (is_method("NOTIFY|UPDATE")) && ($rs==200))
	{
		if(nat_uac_test(1))
		{
			fix_nated_contact();
			return;
		}
	}
	return;
}

event_route[uac:reply] {
    xlog("L_INFO","[kamailio] =>received reply code is: $uac_req(evcode)\n");
}

